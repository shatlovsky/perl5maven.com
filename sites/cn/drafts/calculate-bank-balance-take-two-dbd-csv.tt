=title Calculating bank balance, take two: DBD::CSV
=timestamp 2012-09-07T09:45:56
=indexes DBD::CSV, CSV, SQL, DBI
=status show
=author dmcbride
=translator swuecho
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

本文作者是<a href="http://www.linkedin.com/pub/darin-mcbride/32/a53/184">Darin McBride</a>, 他就职于 IBM 加拿大实验室，
如有兴趣，可以参考他写的<a href="https://www.metacpan.org/author/DMCBRIDE">CPAN 模块</a>. -- Gabor


缘起：看了Gabor的文章<a href="/how-to-calculate-balance-of-bank-accounts-in-csv-file-using-perl">怎样利用CSV文件计算账户余额</a>，
我觉得用<a href="https://metacpan.org/module/DBD::CSV">DBD::CSV</a>可能更好，Gabor 邀请我把我的想法写出来分享，于是有了此文。


=abstract end

<h2>为何用DBD::CSV?</h2>

每次看到有人问Perl 出来 CSV 文件的问题，我总是想到： DBD::CSV。有两个原因：
一、用DBD::CSV来处理CSV文件，比自己写程序解析更通用，甚至比<a href="https://metacpan.org/module/Text::CSV_XS">Text::CSV_XS</a>
更容易移植。


二、如果用DBD::CSV，迫使你把 csv 文件当作关系数据库中的一个表。很多问题反而会因此而简化。

And a bonus reason is that once you realise your data is, well, data,
the natural transition to another database system (SQLite, DB2, Oracle,
whatever is handy) becomes natural.  And since you've already written your
code with DBD::CSV, transitioning to
<a href="https://metacpan.org/module/DBD::DB2">DBD::DB2</a> or
<a href="https://metacpan.org/module/DBD::SQLite">DBD::SQLite</a> (the two I
use the most, YMMV) becomes simpler.

还有一个好处就是，用 DBD::CSV 写的代码，一般同样适用于
<a href="https://metacpan.org/module/DBD::DB2">DBD::DB2</a> 或者
<a href="https://metacpan.org/module/DBD::SQLite">DBD::SQLite</a> 。
它们是相通的。

<h2>解决问题</h2>

<h2></h2>

先看一下我们的CSV文件：

<code>
TranID,Date,AcNo,Type,Amount,ChequeNo,DDNo,Bank,Branch
13520,01-01-2011,5131342,Dr,5000,,,,
13524,01-01-2011,5131342,Dr,1000,,416123,SB,Ashoknagar
13538,08-01-2011,5131342,Cr,1620,19101,,,
13548,17-01-2011,5131342,Cr,3500,19102,,,
13519,01-01-2011,5522341,Dr,2000,14514,,SBM,Hampankatte
13523,01-01-2011,5522341,Cr,500,19121,,,
13529,02-01-2011,5522341,Dr,5000,13211,,SB,Ashoknagar
13539,09-01-2011,5522341,Cr,500,19122,,,
13541,10-01-2011,5522341,Cr,2000,19123,,,
</code>


问题是： <i>怎样计算每个账户的余额？</i>

大致的思路应该是，找出每一个账户的交易，然后根据存入和取出的额度来计算余额。
如果你了解SQL，你会觉得这样的情形很熟悉。

So, it looks to me like we need to add up all the debits (Dr) and credits
(Cr), grouped by the account number (AcNo).  This sounds almost exactly
like SQL, so maybe an SQL solution would be apropos?



<h2>DBI 设置</h2>


除了在程序的初始的：

<code lang="perl">
use strict;
use warnings;
</code>

还需要：

<code lang="perl">
use DBI;
</code>

以上代码中，我们并没有 写<hl> use DBD::CSV </hl>， 因为 <a href="https://metacpan.org/module/DBI">DBI</a> 会自动为我们加载。

<code lang="perl">
use File::Basename qw(dirname);
use File::Spec;

my $dbh = DBI->connect('dbi:CSV:', undef, undef,
             {
                 f_dir => File::Spec->rel2abs(dirname($0)),
                 f_ext => '.csv',
                 csv_eol => "\n",
                 RaiseError => 1,
             });
</code>


例子中，我们加载了几个模块，主要是完成文件路径的操作。然后，告诉 DBI 我们用 CSV 来驱动。
因为CSV 文件不许要用户名和密码，我们用  <hl>undef</hl> 来占位即可。接下来，我们配置CSV 的信息。
为什么要这么写呢？ 因为我们使用了 <hl> use DBD::CSV </hl>， 这些是这个模块的规定。具体可参考其文档。


<h2>SQL部分</h2>

<p>链接好DBI后，我们来进入正题</p>

<code lang="perl">
my $sth = $dbh->prepare(q[
             SELECT
               AcNo,
               SUM(CASE WHEN Type = ? THEN Amount ELSE 0 - Amount DONE)
             FROM
               banktran
             GROUP BY
               AcNo]);

$sth->execute('Dr');
my $res = $sth->fetchall_arrayref();

use Data::Dumper;
print Dumper $res;
</code>

第一个语句，prepare 我们要执行的SQL。SQL语句中 <hl> ? </hl> 的作用是占位。

The SQL also uses a placeholder value.  This is to ensure that invalid
values don't get through.  In this particular case, the value is also
hardcoded, so it doesn't actually gain us anything other than exposure and
experience.

The SQL itself is a bit more involved.  We are telling the SQL engine
that we want to get the account number (<b>AcNo</b>) and the total of
the <b>Amount</b>s from the <b>banktran</b> table (which the f_ext above will tell
DBD::CSV to map to banktran.csv), but when Type is Dr, we want to count <b>Amount</b>
as a positive, otherwise we count it as a negative.  At this point, I'm not sure
if the zero is required here or not, but first let's get something working,
and then we can tweak it.  The <b>GROUP BY</b> tells the SQL engine that
we want to do this select where the sum is applied per AcNo - different AcNo's
will have independant sums.




There is much more to the SQL than this, but as mentioned earlier,
there are many more places to learn SQL than there is Text::CSV_XS, and you
can use those resources to improve your SQL knowledge.  Also, I'm a novice
in SQL, so probably am not the best person to teach it.

Having compiled the SQL, we then call execute which executes the statement,
and then fetchall_arrayref which does pretty much exactly what it says: returns
all of the rows as a single reference to an array.  We then use Data::Dumper
to dump this out to see what type of data we have so we know what steps
to take next.

Executing this so far gives the following output:

<code lang="perl">
$ perl banktran.pl
Bad table or column name: '=' has chars not alphanumeric or underscore!
   at /usr/lib64/perl5/vendor_perl/5.12.3/SQL/Statement.pm line 88
DBD::CSV::db prepare failed: Bad table or column name: '='
   has chars not alphanumeric or underscore!
   at /usr/lib64/perl5/vendor_perl/5.12.3/SQL/Statement.pm line 88
 [for Statement "
           SELECT
             AcNo,
             SUM(CASE WHEN Type = ? THEN Amount ELSE 0 - Amount DONE)
           FROM
             banktran
           GROUP BY
             AcNo"] at banktran.pl line 32.
DBD::CSV::db prepare failed: Bad table or column name: '='
   has chars not alphanumeric or underscore!
   at /usr/lib64/perl5/vendor_perl/5.12.3/SQL/Statement.pm line 88
 [for Statement "
             SELECT
               AcNo,
               SUM(CASE WHEN Type = ? THEN Amount ELSE 0 - Amount DONE)
             FROM
               banktran
             GROUP BY
               AcNo"] at banktran.pl line 32.
</code>

Woops.  It looks like SQL::Statement doesn't support the <b>CASE</b> syntax
that other databases do.  Well, this will mean we have to do a bit more work
in perl to compensate.  And should we want to move to another database in
the future, we may want to mark this so that we can come back to it.  The
solution we will eventually use will also work with other databases, of course,
but may not be quite as "pure" SQL.  And, in general, other databases have
this code done in C and so will be able to do what we will do faster.  Further,
with client/server databases (where the database is not on the same machine
as the perl code that is requesting data), it can also reduce the amount of
network traffic.  Whether these concerns are of any importance to your
project will, of course, depend on what constraints you have.

<h2>Retrying with simpler SQL</h2>

To simplify the SQL such that SQL::Statement will accept it, I've opted
to <b>GROUP BY</b> both the <b>AcNo</b> and the <b>Type</b>.  This will
allow me to total the <b>Amount</b> field for both debits and credits, per account,
and have only a single subtraction to do later.

<code lang="perl">
my $sth = $dbh->prepare(q[
             SELECT
               AcNo,
               Type,
               SUM(Amount)
             FROM
               banktran
             GROUP BY
               AcNo, Type]);

$sth->execute();
my $res = $sth->fetchall_arrayref({});

use Data::Dumper;
print Dumper($res);
</code>

Having replaced the non-working prepare above with this, I get the
following output:

<code lang="perl">
$ perl banktran.pl
$VAR1 = [
          {
            'Type' => 'Dr',
            'AcNo' => '5522341',
            'SUM' => 7000
          },
          {
            'Type' => 'Cr',
            'AcNo' => '5131342',
            'SUM' => 5120
          },
          {
            'Type' => 'Cr',
            'AcNo' => '5522341',
            'SUM' => 3000
          },
          {
            'Type' => 'Dr',
            'AcNo' => '5131342',
            'SUM' => 6000
          }
        ];
</code>

Now we're getting somewhere.  The total debits for 5522341 is 7000,
credits for 5131342 is 5120, etc.  Notice how there's no rhyme or reason
to the output.  That's because we didn't ask the SQL engine to ORDER BY
anything.  It comes back in whatever order it feels like.  We would have to
specify "ORDER BY AcNo, Type" to order it by account number and then, within
each account number, by type (Cr &lt; Dr, of course).

To perform the equivalent SUM(CASE...) from the first attempt, I start
by populating a hash of the above:

<code lang="perl">
# pull together debits and credits.
my %totals;
for my $r (@$res)
{
    $totals{$r->{AcNo}}{$r->{Type}} = $r->{SUM};
}
</code>

The keys at the top are the account numbers, and subkeys are the types
of transactions.  Since there is, by definition of SQL, only one row for
each of these pairings as that is the GROUP BY we did, I don't need to worry
about accidentally clobbering anything here.

<h2>The Output as a table</h2>

During output I do the subtraction.  In this case, I have no idea what
the original requestor really wanted, but we have all the information from
the CSV that we wanted, so it's really not that important.  I've opted to
use one of my favourite modules, <a href="https://metacpan.org/module/Text::Table">Text::Table</a>.

<code lang="perl">
use Text::Table;
my $tb = Text::Table->new("Account\nNumber", "Total\n(Rs)");

$tb->load(
          map {
              [ $_, $totals{$_}{Dr} - $totals{$_}{Cr} ]
          } sort keys %totals
         );

print $tb;
</code>

We load Text::Table, and then create the object.  Its constructor
takes the column headers to use, so I fill that in.  The load could be
done a little more readably, but, again, the main point is where we
do the subtraction of Cr from Dr.  Text::Table wants each row as an
array reference, so we create that via map.  Outside of the map, we
get all of the keys from %totals (from above, that was what we got
from the database as AcNo), and sort them.  Note that this is, by default,
a string sort - if you want numerical sorting, you'll have to provide that.</p>
<p>Inside the map, we create an anonymous array, put the key (AcNo) as the
first column, and perform the subtraction as the second column, this is
the total we wanted from the outset, and then return the array.

<h2>The whole solution</h2>

<p>Putting all this together, we get:</p>

<code lang="perl">
#!/usr/bin/perl

use strict;
use warnings;

use DBI;
use File::Basename qw(dirname);
use File::Spec;

my $dbh = DBI->connect('dbi:CSV:', undef, undef,
              {
                  f_dir => File::Spec->rel2abs(dirname($0)),
                  f_ext => '.csv',
                  csv_eol => "\n",
                  RaiseError => 1,
              });

my $sth = $dbh->prepare(q[
               SELECT
                 AcNo,
                 Type,
                 SUM(Amount)
               FROM
                 banktran
               GROUP BY
                 AcNo, Type]);

$sth->execute();
my $res = $sth->fetchall_arrayref({});

# pull together debits and credits.
my %totals;
for my $r (@$res)
{
    $totals{$r->{AcNo}}{$r->{Type}} = $r->{SUM};
}

use Text::Table;
my $tb = Text::Table->new("Account\nNumber", "Total\n(Rs)");

$tb->load(
          map {
              [ $_, $totals{$_}{Dr} - $totals{$_}{Cr} ]
          } sort keys %totals
         );

print $tb;
</code>

<p>And for output:</p>

<code>
$ perl banktran.pl
Account Total
Number  (Rs)
5131342  880
5522341 4000
</code>

